# 네트워크 프로그래밍

## 네트워크 프로그래밍
소켓 API를 이용하여 네트워크를 사용하는 프로그램을 작성하는 것

## socket이란?
네트워크 프로토콜의 통신 접점, 네트워크의 연결 도구  
운영체제에 의해 제공되는 소프트웨어적인 장치  
리눅스에서는 소켓을 하나의 파일로 다룸 

## socket 생성
```c
#include <sys/socket.h>

int socket(int domain, int type, int protocol);
```
domain - 사용할 프로토콜 체계 (AF_INET, AF_INET6, AF_UNIX)
type - 데이터 전송 방식  

|type|-|
|-|-|
|SOCK_STREAM|TCP 소켓|
|SOCK_DGRAM|UDP 소켓|
|SOCK_RAW|사용자 정의 4계층 통신|  

protocol - 프로토콜 정보, 0번으로 설정하면 각각의 소켓에 기본값(TCP, UDP)로 설정

return - 성공시 파일 디스크립터 번호 반환, 실패시 -1
## socket 주소 
소켓 주소 관련 구조체
```c
#include <sys/socket.h>
//기본적인 주소 저장 구조체
//확장을 위해 사용
struct sockaddr {
    sa_family_t sa_family; //프로토콜 체계
    char sa_data[14];//주소
}

//AF_INET(IPv4) 전용 구조체
//sockaddr로 형변환 가능
struct sockaddr_in {
    sa_family_t sa_family; //AF_INET
    in_port_t sin_port; //port 번호
    struct in_addr sin_addr; // ip주소
}

struct in_addr {
    uint32_t s_addr; //unsigned형 32비트 주소
}
```

bind 함수  
소켓에 주소를 할당하는 함수
```c
#include <sys/types.h>
#include <sys/socket.h>
int bind(int sockfd, const sockaddr* addr, socklen_t addrlen);
//순서대로 파일 디스크립터 번호, 소켓 주소, 주소의 길이
//성공시 0, 실패시 -1 리턴
```

## 바이트 순서
빅 엔디안 : 상위 바이트의 값이 메모리의 작은 주소에 저장
리틀 엔디안 : 하위 바이트의 값이 메모리의 작은 주소에 저장
```
0x12345678 저장시
빅 엔디안 = 0x12 / 0x34 / 0x56 / 0x78
리틀 엔디안 = 0x78 / 0x56 / 0x34 / 0x12
```
네트워크에서 데이터를 주고 받을 때는 빅 엔디안 방식 사용.  
호스트에서는 컴퓨터에 따라 다름. 인텔 계열 컴퓨터는 리틀 엔디안 방식 사용.  
따라서 적절한 변환이 필요함.  

```c
#include <arpa/inet.h>

//host to network
uint_t htonl(uint32_t hostlong);//32비트
uint_t htons(uint16_t hostshort);//16비트
//network to host
uint_t ntohl(uint32_t netlong);//32비트
uint_t ntohs(uint16_t netshort);//16비트
```

## 주소 변환 함수
dotted-decimal 방식(127.0.0.1) 과 2진수 표기를 변환하는 함수들  

```c
#include <sys/socket.h>
#include <netinet/in.h.>
#include <arpa/inet.h>

//in_addr_t 는 uint32_t와 같음

//dotted주소를 32비트 숫자로 변환(네트워크 바이트 오더)
in_addr_t inet_addr(const char* cp);

//dotted 주소를 32비트 숫자로 변환(호스트 바이트 오더)
in_addr_t inet_network(const char *cp);

//dotted 주소를 32비트 숫자로 변환하여 *inp에 저장
int inet_aton(const char *cp, struct in_addr *inp);

//in에 저장된 숫자를 dotted방식 으로 변환
char* inet_ntoa(struct in_addr in);
```
IPv6을 지원하기 위한 함수, IPv4도 지원함
```c
#include <arpa/inet.h>

//src를 숫자로 변환하여 dst에 저장
//af = IP버전, src = dotted 주소, dst = 결과를 저장하는 포인터
int inet_pton(int af, const char *src, void *dst);

//src를 문자열로 변환하여 dst에 저장
//af = IP버전, src = 네트워크 주소 구조체, dst = 결과값 저장 포인터, size = 크기
const char* inet_ntop(int af, const void *src, char *dst, socklen_t size);
```

### 호스트 이름으로 주소 조회

```c
#include <netdb.h>

//도메안 이름으로 IP주소 조회
struct hostent *gethostbyname(const char *name);

//반환하는 hostent 구조체
struct hostent {
    char *h_name; //공식 도메인 이름
    char **h_aliases; // 다른 별명들
    int h_addrtype; // 주소 타입(AF_INET...)
    int h_length; //주소 길이
    char **h_addr_list; // 주소 리스트
}
```

## TCP 소켓
<img src="https://mblogthumb-phinf.pstatic.net/MjAyMDAzMjZfODQg/MDAxNTg1MTg5ODA2MDE1.wo9pAM3mZkdkvgIOJp7paZwDNSAq2XXIe-iFalwImXUg.sLDfI_b4YePptTWd4RaUlQ8JtjleQAPEy57dMBuaMmAg.PNG.okopok5019/image.png?type=w800">

### listen()
```c
#include <sys/types.h>
#include <sys/socket.h>

int listen(int sockfd, int backlog);
```
listen은 클라이언트의 접속 요청을 기다리는 함수이다.  
|||
|-|-|
|sockfd|소켓의 파일 디스크립터 번호|
|backlog|sockfd에 접속을 기다리는 최대 소켓 갯수
|return값|성공시 0, 실패시 -1

### accept()
```c
#include <sys/types.h>
#include <sys/socket.h>

int accept(int sockfd, struct sockaddr* restrict addr, socklen_t* restrict addrlen);
```
accept는 연결 요청을 받아들이는 함수이다.  
클라이언트 소켓의 정보로 새로운 소켓을 만든다.
|||
|-|-|
|sockfd|소켓의 파일 디스크립터 번호|
|addr|연결 요청을 한 소켓의 주소|
|addrlen|addr의 크기|
|return값|성공시 받아들인 소켓의 파일 디스크립터, 실패시 -1

### connect()
```c
#include <sys/types.h>
#include <sys/socket.h>

int connect(int sockfd, const struct sockaddr* addr, socklen_t addrlen);
```
connect는 sockfd와 목적지의 소켓을 연결시켜주는 함수이다.
|||
|-|-|
|sockfd|소켓의 파일 디스크립터 번호|
|addr|목적지의 소켓 주소|
|addrlen|addr의 크기|
|return 값|성공시 0, 실패시 -1|

### send()
```c
#include <sys/types.h>
#include <sys/socket.h>

ssize_t send(int sockfd, const void *buf, size_t len, int flags);
```
send는 데이터를 보내는 함수이며 write()로 대체가 가능하다.  
|||
|-|-|
|sockfd|소켓의 파일 디스크립터 번호|
|*buf|보낼 데이터를 담는 버퍼|
|len|보낼 데이터의 최대 길이|
|return 값|성공시 보낸 바이트 수, 실패시 -1|

### recv()
```c
#include <sys/types.h>
#include <sys/socket.h>

ssize_t recv(int sockfd, void *buf, size_t len, int flags);
```
recv는 받은 데이터를 읽는 함수로 read함수와 대체 가능하다.  
|||
|-|-|
|sockfd|소켓의 파일 디스크립터 번호|
|*buf|받은 데이터를 저장하는 버퍼|
|len|받을 데이터의 최대 길이|
|return 값|성공시 받은 바이트 수, 실패시 -1|





