# 멀티 프로세스(Multi process)
## 단일 프로세스 서버의 한계
단일 프로세스 서버는 데이터를 순차적으로 받기 때문에 여러 클라이언트가 접속했을 경우 먼저 접속한 클라이언트의 연결이 종료되어야 그 다음 접속한 클라이언트가 보낸 데이터를 받는다.  
이 때 첫번째 클라이언트와 접속해 있는 동안 두번째 클라이언트가 데이터를 보내면 첫번째 클라이언트의 연결이 종료될 때 두번째 클라이언트가 보낸 데이터를 한번에 받게 되는 문제가 있다.  
이를 해결하는 방법으로는 
1. Multi process
2. Multi thread
3. Multipelxing  

3가지가 있다.  
첫번째로 muitl process에 대해서 다룬다.  
## 멀티 프로세스
fork 함수를 통해 부모 프로세스에서 자식 프로세스를 생성할 수 있음. 

### fork()
```c
#include <unistd.h>

pid_t fork()
```
성공시 프로세스의 pid값(자식 프로세스을 경우 0), 실패시 -1을 리턴  
fork 함수 호출시에 부모 프로세스의 정보가 자식 프로세스로 복사됨.  
공유되는 것이 아닌 복사되는 것이기 때문에 부모와 자식간의 공유하는 데이터가 없음.  
이후 각각의 프로세스가 독립적으로 실행됨.  

### wait()

```c
#include <sys/wait.h>

pid_t wait(int *status);
```
자식 프로세스의 pid를 리턴, 에러시 -1 리턴  
wait()를 호출하면 자식 프로세스중 하나가 종료될 때 까지 대기함.  
자식 프로세스가 종료되면 wait() 함수를 통해 자식 프로세스의 정보가 부모 프로세스로 전달됨.  
status는 자식 프로세스의 상태와 정보 등을 담고있음. 
```c
WIFEXITED(status) // 자식 프로세스가 정상 종료한 경우 true 리턴
WEXITSATUS(status) // 자식 프로세스의 반환 값
WIFSIGNALED(status) // 자식 프로세스가 시그널에 의해 종료되었을 경우 true 반환
```

